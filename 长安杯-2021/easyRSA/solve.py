#!/usr/bin/env python3.7
from Crypto.Util.number import *

def add(a,b):
    if(a<b):
        a0 = str(b).encode()
        b0 = str(a).encode()
    else:
        a0 = str(a).encode()
        b0 = str(b).encode()
    ans = 0
    for i in range(len(a0)-len(b0)):
        ans = ans*10+a0[i]-48 # a bytes beyond b
    for i in range(len(b0)):
        ans = ans*10+(a0[i+len(a0)-len(b0)]+b0[i]+4)%10 # a + b
    return ans

def mul(a,b):
    if(a<b):
        a0 = str(b).encode()
        b0 = str(a).encode()
    else:
        a0 = str(a).encode()
        b0 = str(b).encode()
    ans = 0
    for i in range(len(b0)):
        ans = ans*10+((a0[i+len(a0)-len(b0)]+2)*(b0[i]+2))%10
    return ans

class Solver:
    def __init__(self):
        self.pq = [(0,0)]
        self.add_p_q = 10399034381787849923326924881454040531711492204619924608227265350044149907274051734345037676383421545973249148286183660679683016947030357640361405556516408
        self.mul_p_q = 6004903250672248020273453078045186428048881010508070095760634049430058892705564009054400328070528434060550830050010084328522605000400260581038846465000861
        self.n = 100457237809578238448997689590363740025639066957321554834356116114019566855447194466985968666777662995007348443263561295712530012665535942780881309520544097928921920784417859632308854225762469971326925931642031846400402355926637518199130760304347996335637140724757568332604740023000379088112644537238901495181

    def mycheck(self, n, p, q):
        if add(p, q) == self.add_p_q % 10 ** n and mul(p, q) == self.mul_p_q % 10 ** n and (p * q) % (10 ** n) == self.n % (10 ** n):
            if (max(p, q), min(p, q)) not in self.pq:
                self.pq.append((max(p, q), min(p, q)))
    
    def solve(self):
        for i in range(154):
            n = i + 1
            pq, self.pq = self.pq, []
            for p, q in pq:
                for p_i in range(10):
                    for q_i in range(10):
                        temp_p = p_i * 10 ** i + p
                        temp_q = q_i * 10 ** i + q
                        self.mycheck(n, temp_p, temp_q)
        return self.pq

solver = Solver()
print(solver.solve())

p = 12092931636613623040737253079065768977037831274116990695362696899634198318309588587556607732878944639910799730236593646983127255905400637167879667181506829
q = 8307103755174226983699771812499382664784661030503034013965679561410051699975573257899430944515587916063550418050690024796566861042630720583592848475010689
assert p * q == solver.n
c = 49042009464540753864186870038605696433949255281829439530955555557471951265762643642510403828448619593655860548966001304965902133517879714352191832895783859451396658166132732818620715968231113019681486494621363269268257297512939412717227009564539512793374347236183475339558666141579267673676878540943373877937
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(c, d, solver.n)
print(m)

